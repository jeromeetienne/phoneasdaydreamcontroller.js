<!DOCTYPE html>
<html lang='en'><head>
<title>Web VR Boilerplate</title>
<meta charset='utf-8'>
<meta name='viewport' content='width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0, shrink-to-fit=no'>
<meta name='mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-capable' content='yes' />
<meta name='apple-mobile-web-app-status-bar-style' content='black-translucent' />
<link rel='stylesheet' href='https://maxcdn.bootstrapcdn.com/font-awesome/4.6.2/css/font-awesome.min.css'>
<style>
html, body {
	width: 100%;
	height: 100%;
	background-color: #000;
	color: #fff;
	margin: 0px;
	padding: 0;
	overflow: hidden;
}

canvas {
	position: absolute;
	top: 0;
}
#fullScreenContainer {
	position: relative;
	width: 100%;
	height: 100%;
}

#buttons {
	position: absolute;
	bottom: 0;
	right: 0;
	z-index: 1;
	/*to prevent mouse selection of the button*/
	user-select: none;
	-webkit-user-select: none;
}
#buttons i {
	color: #ccc;
	font-size: 150%;
	margin-bottom: 0.4em;
	margin-right: 0.4em;
}
#buttons i:hover {
	color: #fff;
	text-shadow: 0px 0px 5px lightblue, 0px 0px 10px lightblue;
	cursor: pointer;
}
</style>
</head>

<body>
	<div id='fullScreenContainer'>
		<div id='buttons'>
			<i class='fa fa-arrows-alt' id='fullscreenButton'></i>
			<i class='fa fa-eye' id='vrButton'></i>
			<i class='fa fa-star' id='resetButton' title='reset position'></i>
		</div>
	</div>
</body>

<script>
WebVRConfig = {
	BUFFER_SCALE: 0.5,
};

document.addEventListener('touchmove', function(event) {
	event.preventDefault();
});
</script>

<!-- three.js library -->
<script src='../vendor/three.js/build/three.js'></script>

<!-- VRControls.js applies the WebVR transformations to a three.js camera object. -->
<script src='../vendor/three.js/examples/js/controls/VRControls.js'></script>

<!-- VREffect.js handles stereo camera setup and rendering.  -->
<script src='../vendor/three.js/examples/js/effects/VREffect.js'></script>
<!-- <script src='../vendor/three.js/examples/js/effects/VREffect-fromweb.js'></script> -->

<!-- A polyfill for the WebVR API.  -->
<script src='../vendor/webvr-polyfill.js'></script>

<script>
var onRenderFcts = []

// Setup three.js WebGL renderer. Note: Antialiasing is a big performance hit.
// Only enable it if you actually need to.
var renderer = new THREE.WebGLRenderer({antialias: false});
renderer.setPixelRatio(Math.floor(window.devicePixelRatio));
renderer.setPixelRatio(1/2);

// Append the canvas element created by the renderer to fullScreenContainer
document.querySelector('#fullScreenContainer').appendChild(renderer.domElement);

// Create a three.js scene.
var scene = new THREE.Scene();

// Create a three.js camera.
var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);

// Apply VR headset positional data to camera.
var controls = new THREE.VRControls(camera);

// Apply VR stereo rendering to renderer.
var effect = new THREE.VREffect(renderer);
effect.setSize(window.innerWidth, window.innerHeight);

// Get the VRDisplay and save it for later.
var vrDisplay = null;
navigator.getVRDisplays().then(function(displays) {
	if (displays.length > 0) {
		vrDisplay = displays[0];
	}
	
	if( vrDisplay !== null ){
		if( vrDisplay.capabilities.canPresent !== true ){
			document.querySelector('#vrButton').style.display = 'none'
		}
	}
});

// Request animation frame loop function
var lastRender = 0;
function animate(timestamp) {
	var delta = Math.min(timestamp - lastRender, 500);
	lastRender = timestamp;
	
	// Update VR headset position and apply to camera.
	controls.update();

	// call each function for the rendering
	onRenderFcts.forEach(function(onRenderFct){
		onRenderFct(delta)
	})
	
	// Render the scene.
	effect.render(scene, camera);
	
	// Keep looping.
	requestAnimationFrame(animate);
}

// Kick off animation loop.
requestAnimationFrame(animate);

//////////////////////////////////////////////////////////////////////////////////
//		Comments
//////////////////////////////////////////////////////////////////////////////////

function onResize() {
	effect.setSize(window.innerWidth, window.innerHeight);
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
}

// Resize the WebGL canvas when we resize and also when we change modes.
window.addEventListener('resize', onResize);
window.addEventListener('vrdisplaypresentchange', function onVRDisplayPresentChange() {
	console.log('onVRDisplayPresentChange');
	onResize();
});

// Button click handlers.
document.querySelector('#fullscreenButton').addEventListener('click', function() {
	var domElement = document.querySelector('#fullScreenContainer')
	// var domElement = document.querySelector('canvas')
	enterFullscreen(domElement);
});
document.querySelector('#vrButton').addEventListener('click', function() {
	vrDisplay.requestPresent([{source: renderer.domElement}]);
});
document.querySelector('#resetButton').addEventListener('click', function() {
	vrDisplay.resetPose();
});

renderer.domElement.addEventListener('click', function(event){
	var element = renderer.domElement
	// check it is the proper click
	if( event.target !== element )	return
	if( vrDisplay.displayName !== 'Mouse and Keyboard VRDisplay (webvr-polyfill)')	return	
	// Ask the browser to lock the pointer
	element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
	if ( /Firefox/i.test( navigator.userAgent ) ) {
		var fullscreenchange = function ( event ) {
			if ( document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element ) {
				document.removeEventListener( 'fullscreenchange', fullscreenchange );
				document.removeEventListener( 'mozfullscreenchange', fullscreenchange );
				element.requestPointerLock();
			}
		};
		document.addEventListener( 'fullscreenchange', fullscreenchange, false );
		document.addEventListener( 'mozfullscreenchange', fullscreenchange, false );
		element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;
		element.requestFullscreen();
	} else {
		element.requestPointerLock();
	}
})

function enterFullscreen (element) {
	if (element.requestFullscreen) {
		element.requestFullscreen();
	} else if (element.mozRequestFullScreen) {
		element.mozRequestFullScreen();
	} else if (element.webkitRequestFullscreen) {
		element.webkitRequestFullscreen();
	} else if (element.msRequestFullscreen) {
		element.msRequestFullscreen();
	}
}
</script>


<script src='../js/threex.gamepadsignals.js'></script>

<script src='../vendor/threex.laser/threex.laserbeam.js'></script>
<script src='../vendor/threex.laser/threex.lasercooked.js'></script>
<script>THREEx.LaserCooked.baseURL	= '../vendor/threex.laser/';</script>


<script>
	//////////////////////////////////////////////////////////////////////////////
	//		Code Separator
	//////////////////////////////////////////////////////////////////////////////
	(function(){
		var geometry	= new THREE.TorusGeometry(0.5-0.15, 0.15);
		//var geometry	= new THREE.SphereGeometry(0.5, 32, 16);
		for(var i = 0; i < 200; i++){
			var material	= new THREE.MeshPhongMaterial({
				color	: 0xffffff,
				specular: 0xffffff,
				shininess: 200,
			});

			var object3d	= new THREE.Mesh( geometry, material );
			object3d.scale.set(1,1,1).multiplyScalar(1/2)
			scene.add( object3d );


			object3d.position.x	= (Math.random()-0.5)*10
			object3d.position.y	= (Math.random()-0.5)*5
			object3d.position.z	= (Math.random()-0.5)*10
			
			object3d.rotation.x	= (Math.random()-0.5)*Math.PI*2
			object3d.rotation.y	= (Math.random()-0.5)*Math.PI*2
			object3d.rotation.z	= (Math.random()-0.5)*Math.PI*2
		}
	})()	
	//////////////////////////////////////////////////////////////////////////////
	//		Code Separator
	//////////////////////////////////////////////////////////////////////////////

	// Add a repeating grid as a skybox.
	var boxWidth = 10;
	var loader = new THREE.TextureLoader();
	loader.load('../images/box.png', function onTextureLoaded(texture) {
		texture.wrapS = THREE.RepeatWrapping;
		texture.wrapT = THREE.RepeatWrapping;
		texture.repeat.set(boxWidth, boxWidth);
		
		var geometry = new THREE.BoxGeometry(boxWidth, boxWidth, boxWidth);
		var material = new THREE.MeshPhongMaterial({
			map: texture,
			// color: 0x01BE00,
			color	: 0xaa8888,
			specular: 0xffffff,
			side: THREE.BackSide
		});
		
		var skybox = new THREE.Mesh(geometry, material);
		scene.add(skybox);



	});

	//////////////////////////////////////////////////////////////////////////////////
	//		comment								//
	//////////////////////////////////////////////////////////////////////////////////

	var light	= new THREE.HemisphereLight( 0xfffff0, 0x101020, 0.2 )
	light.position.set( 0.75, 1, 0.25 )
	scene.add(light)
</script>


<script src='../vendor/three.js/editor/js/libs/signals.min.js'></script>
<script src='../../node_modules/socket.io/node_modules/socket.io-client/socket.io.js'></script>
<script src='../../src/phoneasvrcontrollercontext.js'></script>
<script src='../../src/phoneasvrcontrollerphone.js'></script>
<script src='../js/threex.daydreamcontroller.js'></script>
<script src='../js/threex.gamepadsignals.js'></script>
<script>
	var serverUrl = 'http://'+location.hostname+':4000'
	var phoneAsVRController = new PhoneAsVRController.Context(serverUrl);
	// update phoneAsVRController.viewQuaternion for recalibration
	onRenderFcts.push(function(){
		phoneAsVRController.viewQuaternion = camera.quaternion.toArray()
	})


	function getGamepad(hand){
		// var gamepads = navigator.getGamepads()
		var gamepads = phoneAsVRController.getGamepads()
		for(var i = 0; i < gamepads.length; i++){
			var gamepad = gamepads[i]
			if( gamepad === undefined )	continue
			if( gamepad.hand !== hand )	continue
			return gamepad
		}
		return null
	}
	
	//////////////////////////////////////////////////////////////////////////////
	//		Code Separator
	//////////////////////////////////////////////////////////////////////////////
;(function(){
	createController('right')
	// createController('left')

	function createController(hand){
		var controllerRight = new THREEx.DaydreamController()
		scene.add(controllerRight.object3d)
		var gamepadSignals = new THREEx.GamepadSignals()

		var uiMode = null

		var intersects = []
		onRenderFcts.push(function(){
			var gamepad = getGamepad(hand)
			if( gamepad === null )	return
			controllerRight.updatePosition(camera, gamepad)

			gamepadSignals.update(gamepad)
			
			var actionableObjects = uiMode.getActionableObjects(scene)
			
			var raycaster = controllerRight.getRaycaster()
			
			// compute intersects
			intersects	= raycaster.intersectObjects( actionableObjects );
			
			uiMode.update && uiMode.update(intersects)

			//////////////////////////////////////////////////////////////////////////////
			//		set laser beam  length according to intersects
			//////////////////////////////////////////////////////////////////////////////
			if( intersects.length > 0 ){
				var position	= intersects[0].point
				var distance	= position.distanceTo(raycaster.ray.origin)
				controllerRight._laserBeam.setLength(distance)
			}else{
				controllerRight._laserBeam.setLength(10)
			}
		})
		
		
		//////////////////////////////////////////////////////////////////////////////
		//		Code Separator
		//////////////////////////////////////////////////////////////////////////////
		
		
		
		function gotoUiMode(uiModeType){
			// dispose of old uiMode
			if(uiMode !== null ){
				uiMode.dispose()
			}

			// create new uiMode
			if(uiModeType === 'select'){
				uiMode = new UiModeSelect(gamepadSignals)
			}else if(uiModeType === 'vrMenu'){
				uiMode = new UiModeVrMenu(gamepadSignals)
			}
		}

		// setup initial mode
		gotoUiMode('select')

		////////////////////////////////////////////////////////////////////////////////
		//          Handle long press traclpad to toggle menu
		////////////////////////////////////////////////////////////////////////////////
		
		;(function(){
			var timerId = null
			gamepadSignals.signals.touchStart.add(function(buttonIndex){
				if( buttonIndex !== 2 )	return	
				stopTimerIfNeeded()	
				timerId = setTimeout(function(){
					stopTimerIfNeeded()
					if( uiMode.type !== 'vrMenu' ){
						gotoUiMode('vrMenu')
					}else{
						gotoUiMode('select')						
					}
				}, 1000*0.5)
			})
			gamepadSignals.signals.touchEnd.add(function(buttonIndex){
				if( buttonIndex !== 2 )	return	
				stopTimerIfNeeded()
			})
			function stopTimerIfNeeded(){
				if( timerId !== null ) clearTimeout(timerId)
				timerId = null			
			}
		})()
	}
})()

//////////////////////////////////////////////////////////////////////////////
//		Code Separator
//////////////////////////////////////////////////////////////////////////////
function UiModeSelect(gamepadSignals){
	var _this = this
	this.type = 'select'
	console.log('create UiModeSelect')

	this._selected = null
	this._intersects = []

	this.getActionableObjects = function(scene){
		var clickableObjects = []
		scene.traverse(function(object3d){
			if( object3d.geometry instanceof THREE.TorusGeometry ){
				clickableObjects.push(object3d)
			}
		})
		return clickableObjects
	}
	
	gamepadSignals.signals.touchStart.add(onTouchStart)
	this.dispose = function(){
		gamepadSignals.signals.touchStart.remove(onTouchStart)
	}
	
	this.update = function(intersects){
		this._intersects	= intersects
	}
	return
	
	function onTouchStart(buttonIndex){
		if( buttonIndex !== 0 )	return
		if( _this._intersects.length === 0 )	return
		var object3d = _this._intersects[0].object
		
		object3d.material.color.setHex(0xffffff*Math.random())
		
		_this._selected = object3d
		
		console.log('selecting', object3d)
	}

}

//////////////////////////////////////////////////////////////////////////////
//		Code Separator
//////////////////////////////////////////////////////////////////////////////

function UiModeVrMenu(){
	this.type = 'vrMenu'
	var vrMenu = new THREEx.VRMenu(domEvents, {
		'open' : 'Open app',
		'biggerBrush' : 'Bigger brush',
		'Wow' : 'Wow',
		'smallerBrush' : 'Smaller',
	}, function onSelect(itemKey){
		console.log('selected', itemKey)
	})
	

	vrMenu.object3d.position.z = -4
	// vrMenu.object3d.scale.multiplyScalar(1/2)
	scene.add(vrMenu.object3d)

	this.getActionableObjects = function(scene){
		var clickableObjects = [vrMenu.object3d]
		return clickableObjects
	}

	this.dispose = function(){
		scene.remove(vrMenu.object3d)
	}	
}
</script>
</html>
